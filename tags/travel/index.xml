<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Travel on Free at last</title><link>https://churchmice.github.io/tags/travel/</link><description>Recent content in Travel on Free at last</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>All Rights Reserved</copyright><lastBuildDate>Sun, 19 May 2024 16:12:10 +0800</lastBuildDate><atom:link href="https://churchmice.github.io/tags/travel/index.xml" rel="self" type="application/rss+xml"/><item><title>SECDEC</title><link>https://churchmice.github.io/p/secdec/</link><pubDate>Sun, 19 May 2024 16:12:10 +0800</pubDate><guid>https://churchmice.github.io/p/secdec/</guid><description>&lt;h1 id="介绍"&gt;介绍
&lt;/h1&gt;&lt;p&gt;SECDED是single error correction, double bit detection的简称，也就是可以纠正1比特的错误，能够检测2比特的错误。&lt;/p&gt;
&lt;h1 id="hamming-code"&gt;Hamming Code
&lt;/h1&gt;&lt;p&gt;原理是借助了hamming code,distance是3，也就是说任意两个codeword之间的差距起码是3，hamming distance的计算方法就是对比两个codeword不一样的地方，并进行累加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;uint32&lt;/span&gt; &lt;span class="nf"&gt;hamming_distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;unint32&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;unit32&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;uint32&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;uint32&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//remove the leading 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一个典型的hamming(7,4)的意思是原始数据长度是4,parity长度是3,编码后的消息长度是7.
hamming编码有一定的规则产生生成矩阵，示意图如下，其中Pn代表parity, Dn代表的是数据
&lt;img src="Pasted%20image%2020240519162034.png" alt="" /&gt;
从这张图，我们不难发现如下规律&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pn位于位置是2^i的地方，剩余的位置依次填充Dn&lt;/li&gt;
&lt;li&gt;对于Pi行，如果index的i bit是1，则填充yes,否则填充No&lt;/li&gt;
&lt;li&gt;从左到右, {p3,p2,p1}呈现从1到7依次递增的序列，这为后面的编码提供了基础&lt;/li&gt;
&lt;li&gt;p1 = d1 ^ d2 ^ d4, p2 = d1 ^ d3 ^ d4, p3 = d2 ^ d3 ^ d4&lt;/li&gt;
&lt;li&gt;解码的时候如果p1,p2,p3只有一个等式不成立，那出错的bit处于Pi上&lt;/li&gt;
&lt;li&gt;解码的时候如果p1,p2,p3有超过一个等式不成立，那出错的bit处于Di上&lt;/li&gt;
&lt;li&gt;如果 {p3,p2,p1} = x ( x != 0), 则依次很想查找{p3,p2,p1} =x的那一列，对应的列号就是出错的数据。例如，如果{p3,p2,p1}计算结果是6,那出错的数据就是d3,通过将d3进行flipping就可以把数据纠错回来。原因是p3=1,p2=1,所以出错的数据一定在同时可以被p2和p3 cover的行内，也就是d3和d4,如果是d4出错，那p1也会出错，所以只可能是d3.
对于hamming distance =3的纠错码，只能进行1bit的纠错，因为如果发生了2bit的错误，因为distance是3，有可能和另外一个码的distance是1从而导致误纠错。
一般的，对于distance是d的纠错码，可纠错的bit数是(d-1)/2，可以检错的bit数是d-1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;parity bits (m)和 data bits (k)以及码长(m)的关系如下
&lt;img src="Pasted%20image%2020240519165452.png" alt="" /&gt;&lt;/p&gt;
&lt;h1 id="secded"&gt;SECDED
&lt;/h1&gt;&lt;p&gt;为了能够实现检测两比特错误的功能，可以通过额外添加一比特全局parity来实现。
还是以前面的例子为例，p4 = ^ { p1,p2,p3,d1,d2,d3,d4}
解码的时候计算p1,p2,p3,p4&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;^p4 == 0 : 但是p1,p2,p3有不为0的情况，这种时候就说明发生了两比特翻转的情况&lt;/li&gt;
&lt;li&gt;^p4 == 0 : 并且p1,p2,p3也是0，这说明没有错误发生&lt;/li&gt;
&lt;li&gt;^p4 == 1 : 这种时候说明发生了一比特的翻转,并且是可以纠回来的&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="implementation"&gt;Implementation
&lt;/h1&gt;&lt;h2 id="sw"&gt;SW
&lt;/h2&gt;&lt;p&gt;可以参见
&lt;a href="https://github.com/aa876433/SECDED_hamming_code" target="_blank"&gt;https://github.com/aa876433/SECDED_hamming_code&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id="hw"&gt;HW
&lt;/h2&gt;&lt;p&gt;可以参见
&lt;a href="https://github.com/churchmice/secdec" target="_blank"&gt;https://github.com/churchmice/secdec&lt;/a&gt;
&lt;/p&gt;</description></item><item><title>Gamble</title><link>https://churchmice.github.io/p/gamble/</link><pubDate>Fri, 22 Mar 2024 09:45:55 +0800</pubDate><guid>https://churchmice.github.io/p/gamble/</guid><description>&lt;h1 id="一些原则"&gt;一些原则
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一般来说，如果一加公司的PE只有收益增长率的一半,那这只股票赚钱的可能性就相当大。如果PE是收益增长率的两倍，那这只股票亏钱的可能新就相当大。比如一只股票的PE为20，如果收益增长率有40%,那就可以梭哈。&lt;/li&gt;
&lt;li&gt;美股一般10-12月会有大量的卖出&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>